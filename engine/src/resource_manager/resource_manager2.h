#pragma once

#include "resource_formats.h"
#include "core/non_copyable_non_movable.h"
#include "engine_core/model/model.h"
#include "engine_core/texture/texture.h"
#include "engine_core/level/level.h"
#include "engine_core/font/font.h"
#include "engine_core/video/video.h"
#include "engine_core/material/material.h"
#include "engine_core/material/material_template.h"
#include "engine_core/script/script.h"
#include "engine_core/audio/sound.h"

namespace ad_astris::resource::experimental
{
	class ResourceManager : public NonCopyableNonMovable
	{
		public:
			virtual ~ResourceManager() = default;

			// Must be called immediately after ResourceManager module is loaded and ResourceManager object is created.
			virtual void init() = 0;
			virtual void cleanup() = 0;

			/**
			 * \brief Converts a file from DCC tools to a custom '.aares' file.
			 * Supported 3D-model file formats: gltf (ASCII and binary), obj.
			 * Supported texture file formats: tga, png, jpg, tiff.
			 * \param originalResourcePath must be a valid path to resource with supported formats.
			 * \param engineResourcePath must be a valid path to the folder where you want to save the new aares file.
			 * This path must be a relative path that based on folder {project_root_path}/content
			 * \param conversionContext if nondefault value, must be a valid pointer to appropriate conversion context.
			 * For example, for ecore::Model it must be ecore::ModelConversionContext object
			 * \return An array of UUIDs for the new resources if everything has been loaded correctly, otherwise array is empty.
			 */
			virtual std::vector<UUID> convert_to_engine_format(
				const io::URI& originalResourcePath,
				const io::URI& engineResourcePath,
				void* conversionContext = nullptr) = 0;
			virtual void save_resources() const = 0;
			virtual void save_resource(UUID uuid) const = 0;
			virtual void save_resource(const std::string& name) const = 0;
			virtual void unload_resource(UUID uuid) = 0;
			virtual void unload_resource(const std::string& name) = 0;
			virtual void destroy_resource(UUID uuid) = 0;
			virtual void destroy_resource(const std::string& name) = 0;

			virtual ResourceAccessor<ecore::Level> create_level(const ecore::LevelCreateInfo& createInfo) = 0;
			virtual ResourceAccessor<ecore::Material> create_material(const ecore::MaterialCreateInfo& createInfo) = 0;
			virtual ResourceAccessor<ecore::Script> create_script(const ecore::ScriptCreateInfo& createInfo) = 0;
			virtual ResourceAccessor<ecore::MaterialTemplate> create_material_template(const ecore::MaterialTemplateCreateInfo& createInfo) = 0;

			/**
			 * \brief If Model has not previously been loaded, it will be loaded automatically. Otherwise method returns
			 * pointer to the loaded Model.
			 * \param uuid must be a valid Model UUID that was previously generated by convert_to_engine_format method.
			 * \return ResourceAccessor with Model pointer if UUID is correct, otherwise returns ResourceAccessor
			 * with nullptr and logs an error.
			 */
			virtual ResourceAccessor<ecore::Model> get_model(UUID uuid) const = 0;

			/**
			 * \brief If Model has not previously been loaded, it will be loaded automatically. Otherwise method returns
			 * pointer to the loaded Model.
			 * \param modelName must be a valid Model name that was previously generated by convert_to_engine_format method.
			 * Name index (e.g. name Robot1, where 1 is the name index) is important, and without correct name index method will return
			 * an incorrect data.
			 * \return ResourceAccessor with Model pointer if name is correct, otherwise returns ResourceAccessor
			 * with nullptr and logs an error.
			 */
			virtual ResourceAccessor<ecore::Model> get_model(const std::string& modelName) const = 0;

			/**
			 * \brief If Texture has not previously been loaded, it will be loaded automatically. Otherwise method returns
			 * pointer to the loaded Texture.
			 * \param uuid must be a valid Texture UUID that was previously generated by convert_to_engine_format method.
			 * \return ResourceAccessor with Texture pointer if UUID is correct, otherwise returns ResourceAccessor
			 * with nullptr and logs an error.
			 */
			virtual ResourceAccessor<ecore::Texture> get_texture(UUID uuid) const = 0;

			/**
			 * \brief If Texture has not previously been loaded, it will be loaded automatically. Otherwise method returns
			 * pointer to the loaded Texture.
			 * \param textureName must be a valid Texture name that was previously generated by convert_to_engine_format method.
			 * Name index (e.g. name Opaque1, where 1 is the name index) is important, and without correct name index method will return
			 * an incorrect data.
			 * \return ResourceAccessor with Texture pointer if name is correct, otherwise returns ResourceAccessor
			 * with nullptr and logs an error.
			 */
			virtual ResourceAccessor<ecore::Texture> get_texture(const std::string& textureName) const = 0;

			/**
			 * \brief If Level has not previously been loaded, it will be loaded automatically. Otherwise method returns
			 * pointer to the loaded Level.
			 * \param uuid must be a valid Level UUID that was previously generated by convert_to_engine_format method.
			 * \return ResourceAccessor with Level pointer if UUID is correct, otherwise returns ResourceAccessor
			 * with nullptr and logs an error.
			 */
			virtual ResourceAccessor<ecore::Level> get_level(UUID uuid) const = 0;

			/**
			 * \brief If Level has not previously been loaded, it will be loaded automatically. Otherwise method returns
			 * pointer to the loaded Level.
			 * \param levelName must be a valid Level name that was previously generated by convert_to_engine_format method.
			 * Name index (e.g. name Room1, where 1 is the name index) is important, and without correct name index method will return
			 * an incorrect data.
			 * \return ResourceAccessor with Level pointer if name is correct, otherwise returns ResourceAccessor
			 * with nullptr and logs an error.
			 */
			virtual ResourceAccessor<ecore::Level> get_level(const std::string& levelName) const = 0;

			/**
			 * \brief If Material has not previously been loaded, it will be loaded automatically. Otherwise method returns
			 * pointer to the loaded Material.
			 * \param uuid must be a valid Material UUID that was previously generated by create_material method.
			 * \return ResourceAccessor with Material pointer if UUID is correct, otherwise returns ResourceAccessor
			 * with nullptr and logs an error.
			 */
			virtual ResourceAccessor<ecore::Material> get_material(UUID uuid) const = 0;
		
			/**
			 * \brief If Material has not previously been loaded, it will be loaded automatically. Otherwise method returns
			 * pointer to the loaded Material.
			 * \param materialName must be a valid Material name that was previously generated by create_material method.
			 * Name index (e.g. name Room1, where 1 is the name index) is important, and without correct name index method will return
			 * an incorrect data.
			 * \return ResourceAccessor with Material pointer if name is correct, otherwise returns ResourceAccessor
			 * with nullptr and logs an error.
			 */
			virtual ResourceAccessor<ecore::Material> get_material(const std::string& materialName) const = 0;

			/**
			 * \brief If MaterialTemplate has not previously been loaded, it will be loaded automatically. Otherwise method returns
			 * pointer to the loaded MaterialTemplate.
			 * \param uuid must be a valid MaterialTemplate UUID that was previously generated by create_material method.
			 * \return ResourceAccessor with MaterialTemplate pointer if UUID is correct, otherwise returns ResourceAccessor
			 * with nullptr and logs an error.
			 */
			virtual ResourceAccessor<ecore::MaterialTemplate> get_material_template(UUID uuid) const = 0;
			
			/**
			 * \brief If MaterialTemplate has not previously been loaded, it will be loaded automatically. Otherwise method returns
			 * pointer to the loaded MaterialTemplate.
			 * \param materialTemplateName must be a valid MaterialTemplate name that was previously generated by create_material method.
			 * Name index (e.g. name Room1, where 1 is the name index) is important, and without correct name index method will return
			 * an incorrect data.
			 * \return ResourceAccessor with MaterialTemplate pointer if name is correct, otherwise returns ResourceAccessor
			 * with nullptr and logs an error.
			 */
			virtual ResourceAccessor<ecore::MaterialTemplate> get_material_template(const std::string& materialTemplateName) const = 0;

			/**
			 * \brief If Script has not previously been loaded, it will be loaded automatically. Otherwise method returns
			 * pointer to the loaded Script.
			 * \param uuid must be a valid Script UUID that was previously generated by create_script method.
			 * \return ResourceAccessor with Script pointer if UUID is correct, otherwise returns ResourceAccessor
			 * with nullptr and logs an error.
			 */
			virtual ResourceAccessor<ecore::Script> get_script(UUID uuid) const = 0;

			/**
			 * \brief If Script has not previously been loaded, it will be loaded automatically. Otherwise method returns
			 * pointer to the loaded Script.
			 * \param scriptName must be a valid Script name that was previously generated by create_script method.
			 * Name index (e.g. name Room1, where 1 is the name index) is important, and without correct name index method will return
			 * an incorrect data.
			 * \return ResourceAccessor with Script pointer if name is correct, otherwise returns ResourceAccessor
			 * with nullptr and logs an error.
			 */
			virtual ResourceAccessor<ecore::Script> get_script(const std::string& scriptName) const = 0;

			/**
			 * \brief If Video has not previously been loaded, it will be loaded automatically. Otherwise method returns
			 * pointer to the loaded Video.
			 * \param uuid must be a valid Video UUID that was previously generated by convert_to_engine_format method.
			 * \return ResourceAccessor with Video pointer if UUID is correct, otherwise returns ResourceAccessor
			 * with nullptr and logs an error.
			 */
			virtual ResourceAccessor<ecore::Video> get_video(UUID uuid) const = 0;

			/**
			 * \brief If Video has not previously been loaded, it will be loaded automatically. Otherwise method returns
			 * pointer to the loaded Video.
			 * \param videoName must be a valid Video name that was previously generated by create_script method.
			 * Name index (e.g. name Room1, where 1 is the name index) is important, and without correct name index method will return
			 * an incorrect data.
			 * \return ResourceAccessor with Video pointer if name is correct, otherwise returns ResourceAccessor
			 * with nullptr and logs an error.
			 */
			virtual ResourceAccessor<ecore::Video> get_video(const std::string& videoName) const = 0;

			/**
			 * \brief If Font has not previously been loaded, it will be loaded automatically. Otherwise method returns
			 * pointer to the loaded Font.
			 * \param uuid must be a valid Font UUID that was previously generated by convert_to_engine_format method.
			 * \return ResourceAccessor with Font pointer if UUID is correct, otherwise returns ResourceAccessor
			 * with nullptr and logs an error.
			 */
			virtual ResourceAccessor<ecore::Font> get_font(UUID uuid) const = 0;

			/**
			 * \brief If Font has not previously been loaded, it will be loaded automatically. Otherwise method returns
			 * pointer to the loaded Font.
			 * \param fontName must be a valid Font name that was previously generated by create_script method.
			 * Name index (e.g. name Room1, where 1 is the name index) is important, and without correct name index method will return
			 * an incorrect data.
			 * \return ResourceAccessor with Font pointer if name is correct, otherwise returns ResourceAccessor
			 * with nullptr and logs an error.
			 */
			virtual ResourceAccessor<ecore::Font> get_font(const std::string& fontName) const = 0;

			/**
			 * \brief If Sound has not previously been loaded, it will be loaded automatically. Otherwise method returns
			 * pointer to the loaded Sound.
			 * \param uuid must be a valid Sound UUID that was previously generated by convert_to_engine_format method.
			 * \return ResourceAccessor with Sound pointer if UUID is correct, otherwise returns ResourceAccessor
			 * with nullptr and logs an error.
			 */
			virtual ResourceAccessor<ecore::Sound> get_sound(UUID uuid) const = 0;

			/**
			 * \brief If Sound has not previously been loaded, it will be loaded automatically. Otherwise method returns
			 * pointer to the loaded Sound.
			 * \param soundName must be a valid Sound name that was previously generated by create_script method.
			 * Name index (e.g. name Room1, where 1 is the name index) is important, and without correct name index method will return
			 * an incorrect data.
			 * \return ResourceAccessor with Sound pointer if name is correct, otherwise returns ResourceAccessor
			 * with nullptr and logs an error.
			 */
			virtual ResourceAccessor<ecore::Sound> get_sound(const std::string& soundName) const = 0;

			virtual ResourceType get_resource_type(UUID uuid) const = 0;
			virtual std::string get_resource_name(UUID uuid) const = 0;
			virtual UUID get_resource_uuid(const std::string& resourceName) const = 0;
			virtual bool is_resource_loaded(UUID uuid) const = 0;
			virtual bool is_model_format_supported(const std::string& extension) const = 0;
			virtual bool is_texture_format_supported(const std::string& extension) const = 0;
			virtual bool is_script_format_supported(const std::string& extension) const = 0;
			virtual bool is_video_format_supported(const std::string& extension) const = 0;
			virtual bool is_font_format_supported(const std::string& extension) const = 0;
			virtual bool is_sound_format_supported(const std::string& extension) const = 0;

			/**
			 * \brief If Resource has not previously been loaded, it will be loaded automatically. Otherwise method returns
			 * pointer to the loaded Resource.
			 * \tparam Resource must be one of the supported Resource types, otherwise incorrect behavior. Supported
			 * resource types: ecore::Model, ecore::Texture, ecore::Level, ecore::Material, ecore::Script, ecore::Font,
			 * ecore::Video.
			 * \param resourceName must be a valid Resource name that was previously generated by convert_to_engine_format method.
			 * Name index (e.g. name Room1, where 1 is the name index) is important, and without correct name index method will return
			 * an incorrect data.
			 * \return ResourceAccessor with Resource pointer if name is correct, otherwise returns ResourceAccessor
			 * with nullptr and logs an error.
			 */
			template<typename Resource>
			ResourceAccessor<Resource> get_resource(const std::string& resourceName) const
			{
				if constexpr (std::is_same_v<Resource, ecore::Model>)
					return get_model(resourceName);
				if constexpr (std::is_same_v<Resource, ecore::Texture>)
					return get_texture(resourceName);
				if constexpr (std::is_same_v<Resource, ecore::Level>)
					return get_level(resourceName);
				if constexpr (std::is_same_v<Resource, ecore::Material>)
					return get_material(resourceName);
				if constexpr (std::is_same_v<Resource, ecore::Script>)
					return get_script(resourceName);
				if constexpr (std::is_same_v<Resource, ecore::Video>)
					return get_video(resourceName);
				if constexpr (std::is_same_v<Resource, ecore::Font>)
					return get_font(resourceName);
				if constexpr (std::is_same_v<Resource, ecore::Sound>)
					return get_sound(resourceName);
				if constexpr (std::is_same_v<Resource, ecore::MaterialTemplate>)
					return get_material_template(resourceName);
				
				LOG_ERROR("ResourceManager::get_resource(): Engine does not support resource type {}", get_type_name<Resource>())
				return ResourceAccessor<Resource>{};
			}

			/**
			 * \brief If Resource has not previously been loaded, it will be loaded automatically. Otherwise method returns
			 * pointer to the loaded Resource.
			 * \tparam Resource must be one of the supported Resource types, otherwise incorrect behavior. Supported
			 * resource types: ecore::Model, ecore::Texture, ecore::Level.
			 * \param uuid must be a valid Resource UUID that was previously generated by convert_to_engine_format method.
			 * \return ResourceAccessor with Resource pointer if UUID is correct, otherwise returns ResourceAccessor
			 * with nullptr and logs an error.
			 */
			template<typename Resource>
			ResourceAccessor<Resource> get_resource(UUID uuid) const
			{
				if constexpr (std::is_same_v<Resource, ecore::Model>)
					return get_model(uuid);
				if constexpr (std::is_same_v<Resource, ecore::Texture>)
					return get_texture(uuid);
				if constexpr (std::is_same_v<Resource, ecore::Level>)
					return get_level(uuid);
				if constexpr (std::is_same_v<Resource, ecore::Material>)
					return get_material(uuid);
				if constexpr (std::is_same_v<Resource, ecore::Script>)
					return get_script(uuid);
				if constexpr (std::is_same_v<Resource, ecore::Video>)
					return get_video(uuid);
				if constexpr (std::is_same_v<Resource, ecore::Font>)
					return get_font(uuid);
				if constexpr (std::is_same_v<Resource, ecore::Sound>)
					return get_sound(uuid);
				if constexpr (std::is_same_v<Resource, ecore::MaterialTemplate>)
					return get_material_template(uuid);
				
				LOG_ERROR("ResourceManager::get_resource(): Engine does not support resource type {}", get_type_name<Resource>())
				return ResourceAccessor<Resource>{};
			}
	};
}