#pragma once

#include "resource_formats.h"
#include "core/global_objects.h"
#include "core/non_copyable_non_movable.h"
#include "engine_core/model/model.h"
#include "engine_core/texture/texture.h"
#include "engine_core/level/level.h"

namespace ad_astris::resource::experimental
{
	struct ResourceManagerInitContext
	{
		GlobalObjectContext* globalObjectContext{ nullptr };
	};
	
	class ResourceManager : public NonCopyableNonMovable
	{
		public:
			virtual ~ResourceManager() = default;

			// Must be called immediately after ResourceManager module is loaded and ResourceManager object is created.
			virtual void init(const ResourceManagerInitContext& initContext) = 0;
			virtual void cleanup() = 0;

			/**
			 * \brief Converts a file from DCC tools to a custom '.aares' file.
			 * Supported 3D-model file formats: gltf (ASCII and binary), obj.
			 * Supported texture file formats: tga, png, jpg, tiff.
			 * \param originalResourcePath must be a valid path to resource with supported formats.
			 * \param engineResourcePath must be a valid path to the folder where you want to save the new aares file.
			 * This path must be a relative path that based on folder {project_root_path}/content
			 * \param conversionContext if nondefault value, must be a valid pointer to appropriate conversion context.
			 * For example, for ecore::Model it must be ecore::ModelConversionContext object
			 * \return An array of UUIDs for the new resources if everything has been loaded correctly, otherwise array is empty.
			 */
			virtual std::vector<UUID> convert_to_engine_format(
				const io::URI& originalResourcePath,
				const io::URI& engineResourcePath,
				void* conversionContext = nullptr) = 0;
			virtual void save_resources() const = 0;
			virtual void save_resource(UUID uuid) const = 0;
			virtual void save_resource(const std::string& name) const = 0;
			virtual void unload_resource(UUID uuid) = 0;
			virtual void unload_resource(const std::string& name) = 0;
			virtual void destroy_resource(UUID uuid) = 0;
			virtual void destroy_resource(const std::string& name) = 0;

			/**
			 * \brief If Model has not previously been loaded, it will be loaded automatically. Otherwise method returns
			 * pointer to the loaded Model.
			 * \param uuid must be a valid Model UUID that was previously generated by convert_to_engine_format method.
			 * \return ResourceAccessor with Model pointer if UUID is correct, otherwise returns ResourceAccessor
			 * with nullptr and log an error.
			 */
			virtual ResourceAccessor<ecore::Model> get_model(UUID uuid) const = 0;

			/**
			 * \brief If Model has not previously been loaded, it will be loaded automatically. Otherwise method returns
			 * pointer to the loaded Model.
			 * \param modelName must be a valid Model name that was previously generated by convert_to_engine_format method.
			 * Name index (e.g. name Robot1, where 1 is the name index) is important, and without correct name index method will return
			 * an incorrect data.
			 * \return ResourceAccessor with Model pointer if name is correct, otherwise returns ResourceAccessor
			 * with nullptr and log an error.
			 */
			virtual ResourceAccessor<ecore::Model> get_model(const std::string& modelName) const = 0;

			/**
			 * \brief If Texture has not previously been loaded, it will be loaded automatically. Otherwise method returns
			 * pointer to the loaded Texture.
			 * \param uuid must be a valid Texture UUID that was previously generated by convert_to_engine_format method.
			 * \return ResourceAccessor with Texture pointer if UUID is correct, otherwise returns ResourceAccessor
			 * with nullptr and log an error.
			 */
			virtual ResourceAccessor<ecore::Texture> get_texture(UUID uuid) const = 0;

			/**
			 * \brief If Texture has not previously been loaded, it will be loaded automatically. Otherwise method returns
			 * pointer to the loaded Texture.
			 * \param textureName must be a valid Texture name that was previously generated by convert_to_engine_format method.
			 * Name index (e.g. name Opaque1, where 1 is the name index) is important, and without correct name index method will return
			 * an incorrect data.
			 * \return ResourceAccessor with Texture pointer if name is correct, otherwise returns ResourceAccessor
			 * with nullptr and log an error.
			 */
			virtual ResourceAccessor<ecore::Texture> get_texture(const std::string& textureName) const = 0;

			/**
			 * \brief If Level has not previously been loaded, it will be loaded automatically. Otherwise method returns
			 * pointer to the loaded Level.
			 * \param uuid must be a valid Level UUID that was previously generated by convert_to_engine_format method.
			 * \return ResourceAccessor with Level pointer if UUID is correct, otherwise returns ResourceAccessor
			 * with nullptr and log an error.
			 */
			virtual ResourceAccessor<ecore::Level> get_level(UUID uuid) const = 0;

			/**
			 * \brief If Level has not previously been loaded, it will be loaded automatically. Otherwise method returns
			 * pointer to the loaded Level.
			 * \param levelName must be a valid Level name that was previously generated by convert_to_engine_format method.
			 * Name index (e.g. name Room1, where 1 is the name index) is important, and without correct name index method will return
			 * an incorrect data.
			 * \return ResourceAccessor with Level pointer if name is correct, otherwise returns ResourceAccessor
			 * with nullptr and log an error.
			 */
			virtual ResourceAccessor<ecore::Level> get_level(const std::string& levelName) const = 0;

			virtual ResourceType get_resource_type(UUID uuid) const = 0;
			virtual std::string get_resource_name(UUID uuid) const = 0;
			virtual UUID get_resource_uuid(const std::string& resourceName) const = 0;
			virtual bool is_resource_loaded(UUID uuid) const = 0;
			virtual bool is_supported_model_format(const std::string& extension) const = 0;
			virtual bool is_supported_texture_format(const std::string& extension) const = 0;

			/**
			 * \brief If Resource has not previously been loaded, it will be loaded automatically. Otherwise method returns
			 * pointer to the loaded Resource.
			 * \tparam Resource must be one of the supported Resource types, otherwise incorrect behavior. Supported
			 * resource types: ecore::Model, ecore::Texture, ecore::Level.
			 * \param resourceName must be a valid Resource name that was previously generated by convert_to_engine_format method.
			 * Name index (e.g. name Room1, where 1 is the name index) is important, and without correct name index method will return
			 * an incorrect data.
			 * \return ResourceAccessor with Resource pointer if name is correct, otherwise returns ResourceAccessor
			 * with nullptr and log an error.
			 */
			template<typename Resource>
			ResourceAccessor<Resource> get_resource(const std::string& resourceName) const
			{
				if constexpr (std::is_same_v<Resource, ecore::Model>)
					return get_model(resourceName);
				if constexpr (std::is_same_v<Resource, ecore::Texture>)
					return get_texture(resourceName);
				if constexpr (std::is_same_v<Resource, ecore::Level>)
					return get_level(resourceName);
				
				LOG_ERROR("ResourceManager::get_resource(): Engine does not support resource type {}", get_type_name<Resource>())
				return ResourceAccessor<Resource>{};
			}

			/**
			 * \brief If Resource has not previously been loaded, it will be loaded automatically. Otherwise method returns
			 * pointer to the loaded Resource.
			 * \tparam Resource must be one of the supported Resource types, otherwise incorrect behavior. Supported
			 * resource types: ecore::Model, ecore::Texture, ecore::Level.
			 * \param uuid must be a valid Resource UUID that was previously generated by convert_to_engine_format method.
			 * \return ResourceAccessor with Resource pointer if UUID is correct, otherwise returns ResourceAccessor
			 * with nullptr and log an error.
			 */
			template<typename Resource>
			ResourceAccessor<Resource> get_resource(UUID uuid) const
			{
				if constexpr (std::is_same_v<Resource, ecore::Model>)
					return get_model(uuid);
				if constexpr (std::is_same_v<Resource, ecore::Texture>)
					return get_texture(uuid);
				if constexpr (std::is_same_v<Resource, ecore::Level>)
					return get_level(uuid);
				
				LOG_ERROR("ResourceManager::get_resource(): Engine does not support resource type {}", get_type_name<Resource>())
				return ResourceAccessor<Resource>{};
			}
	};
}